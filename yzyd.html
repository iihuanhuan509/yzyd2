<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>圆周运动交互教程</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/p5@1.4.2/lib/p5.js"></script>
    <style>
        body {
            font-family: 'Source Han Sans CN', 'Microsoft YaHei', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f9f9f9;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1, h2, h3 {
            color: #2563eb;
            margin-top: 1.5em;
            margin-bottom: 0.8em;
        }
        
        h1 {
            font-size: 2.5rem;
            text-align: center;
            margin-bottom: 1.5rem;
            color: #1e40af;
            border-bottom: 2px solid #3b82f6;
            padding-bottom: 10px;
        }
        
        h2 {
            font-size: 1.8rem;
            border-left: 5px solid #3b82f6;
            padding-left: 15px;
        }
        
        h3 {
            font-size: 1.5rem;
        }
        
        p {
            margin-bottom: 1.2em;
            text-align: justify;
        }
        
        .formula {
            background-color: #f0f4ff;
            padding: 10px;
            border-radius: 5px;
            margin: 15px 0;
            text-align: center;
            font-size: 1.1rem;
        }
        
        .canvas-container {
            width: 100%;
            margin: 20px auto;
            text-align: center;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 15px;
        }
        
        .interactive-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin: 15px 0;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 250px;
        }
        
        input[type="range"] {
            flex-grow: 1;
        }
        
        .btn {
            background-color: #3b82f6;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .btn:hover {
            background-color: #2563eb;
        }
        
        .info-box {
            background-color: #e0f2fe;
            border-left: 4px solid #38bdf8;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 5px 5px 0;
        }
        
        .warning-box {
            background-color: #fff7ed;
            border-left: 4px solid #fb923c;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 5px 5px 0;
        }
        
        .tip-box {
            background-color: #ecfdf5;
            border-left: 4px solid #34d399;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 5px 5px 0;
        }
        
        .grid-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 30px 0;
        }
        
        @media (max-width: 768px) {
            .grid-container {
                grid-template-columns: 1fr;
            }
        }
        
        .highlight {
            background-color: #fef3c7;
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        .card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 20px;
            margin: 20px 0;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: center;
        }
        
        th {
            background-color: #f3f4f6;
            font-weight: bold;
        }
        
        tr:nth-child(even) {
            background-color: #f9fafb;
        }

        .katex-display {
            overflow-x: auto;
            overflow-y: hidden;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>圆周运动交互式教程</h1>
        
        <div class="info-box">
            <p class="font-bold">适用对象：</p>
            <p>大一新生，物理学基础课程</p>
            <p class="font-bold">学习目标：</p>
            <p>通过交互式可视化，深入理解圆周运动的基本概念、特性和应用</p>
        </div>
        
        <section>
            <h2>引言</h2>
            <p>圆周运动是物理学中最基本的曲线运动形式之一，它在自然现象和工程应用中都有重要作用。从行星绕太阳运动，到电子绕原子核运动，再到日常生活中的风扇旋转，圆周运动无处不在。</p>
            <p>本教程将通过交互式可视化，帮助你理解圆周运动的核心概念。你可以调整各种参数，观察它们如何影响运动特性，从而建立直观的物理概念。</p>
        </section>
        
        <section>
            <h2>平面极坐标系</h2>
            <p>为了方便描述圆周运动，我们首先需要了解平面极坐标系。在这个坐标系中，点的位置由到原点的距离（r）和与参考轴（通常是x轴正方向）的夹角（θ）来确定。</p>
            
            <div class="canvas-container">
                <div id="polar-coordinates-canvas"></div>
                <div class="interactive-controls">
                    <div class="control-group">
                        <label for="radius-slider">半径 (r):</label>
                        <div class="slider-container">
                            <input type="range" id="radius-slider" min="10" max="150" value="100" class="w-full">
                            <span id="radius-value">100</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="angle-slider">角度 (θ):</label>
                        <div class="slider-container">
                            <input type="range" id="angle-slider" min="0" max="360" value="45" class="w-full">
                            <span id="angle-value">45°</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <p>在平面极坐标系中，我们可以通过以下公式将极坐标 (r, θ) 转换为直角坐标 (x, y)：</p>
            <div class="formula">
                <div id="formula-conversion1"></div>
                <div id="formula-conversion2"></div>
            </div>
            
            <div class="tip-box">
                <p class="font-bold">小提示：</p>
                <p>在物理学中，角度θ通常以弧度为单位，而不是角度。1弧度 ≈ 57.3°，360° = 2π弧度。</p>
            </div>
        </section>
        
        <section>
            <h2>圆周运动的角速度</h2>
            <p>当质点在圆周上运动时，它的位矢（从原点到质点的矢量）与参考轴之间的角度θ随时间变化。角速度是描述这种变化率的物理量，定义为角度随时间的变化率：</p>
            
            <div class="formula">
                <div id="formula-angular-velocity"></div>
            </div>
            
            <p>角速度的单位是弧度每秒(rad/s)。在圆周运动中，线速率v（物体移动的速度大小）与角速度ω之间存在重要关系：</p>
            
            <div class="formula">
                <div id="formula-v-omega"></div>
            </div>
            
            <p>这意味着在同一圆周运动中，线速率等于圆的半径与角速度的乘积。</p>
            
            <div class="canvas-container">
                <div id="angular-velocity-canvas"></div>
                <div class="interactive-controls">
                    <div class="control-group">
                        <label for="omega-slider">角速度 (ω):</label>
                        <div class="slider-container">
                            <input type="range" id="omega-slider" min="0.5" max="5" step="0.1" value="2" class="w-full">
                            <span id="omega-value">2 rad/s</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="radius-slider2">半径 (r):</label>
                        <div class="slider-container">
                            <input type="range" id="radius-slider2" min="30" max="150" value="80" class="w-full">
                            <span id="radius-value2">80</span>
                        </div>
                    </div>
                </div>
                <div class="mt-4">
                    <p><strong>线速率 (v): <span id="linear-velocity">160 单位/秒</span></strong></p>
                    <p><strong>周期 (T): <span id="period">3.14 秒</span></strong></p>
                </div>
            </div>
            
            <div class="info-box">
                <p class="font-bold">重要概念：</p>
                <ul class="list-disc ml-5">
                    <li>周期 (T)：完成一周所需的时间，与角速度关系为 T = 2π/ω</li>
                    <li>频率 (f)：单位时间内完成的圈数，f = 1/T = ω/2π</li>
                </ul>
            </div>
        </section>
        
        <section>
            <h2>匀速率圆周运动</h2>
            <p>匀速率圆周运动是指质点在圆周上运动时，速度大小（速率）保持不变，但方向不断变化的运动。在这种运动中，角速度ω是恒定的。</p>
            
            <h3>向心加速度</h3>
            <p>尽管匀速率圆周运动中速率保持不变，但由于速度方向不断变化，质点仍然具有加速度。这种加速度称为<strong>向心加速度</strong>，其特点是：</p>
            <ul class="list-disc ml-8 my-4">
                <li>方向始终指向圆心</li>
                <li>大小为：</li>
            </ul>
            
            <div class="formula">
                <div id="formula-centripetal-acceleration"></div>
            </div>
            
            <p>向心加速度只改变速度的方向，不改变速度的大小。这是理解圆周运动的关键点之一。</p>
            
            <div class="canvas-container">
                <div id="uniform-circular-motion-canvas"></div>
                <div class="interactive-controls">
                    <div class="control-group">
                        <label for="velocity-slider">速率 (v):</label>
                        <div class="slider-container">
                            <input type="range" id="velocity-slider" min="50" max="200" value="100" class="w-full">
                            <span id="velocity-value">100 单位/秒</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="radius-slider3">半径 (r):</label>
                        <div class="slider-container">
                            <input type="range" id="radius-slider3" min="30" max="120" value="80" class="w-full">
                            <span id="radius-value3">80</span>
                        </div>
                    </div>
                    <button id="toggle-acceleration" class="btn">显示/隐藏向心加速度</button>
                </div>
                <div class="mt-4">
                    <p><strong>向心加速度 (a<sub>n</sub>): <span id="centripetal-acceleration">125 单位/秒<sup>2</sup></span></strong></p>
                    <p><strong>角速度 (ω): <span id="angular-velocity-calc">1.25 rad/s</span></strong></p>
                </div>
            </div>
            
            <div class="warning-box">
                <p class="font-bold">常见误解：</p>
                <p>向心加速度并不是一种新的加速度类型，它就是加速度在圆周运动特定情况下的表现。向心加速度不会增加物体的速率，它只改变速度的方向。</p>
            </div>
        </section>
        
        <section>
            <h2>变速圆周运动</h2>
            <p>变速圆周运动是指质点在圆周上运动时，速度的大小和方向都在变化的运动。这种情况比匀速圆周运动更复杂，但也更接近现实世界中的许多实际情况。</p>
            
            <h3>加速度分解</h3>
            <p>在变速圆周运动中，加速度可以分解为两个互相垂直的分量：</p>
            
            <div class="grid-container">
                <div class="card">
                    <h4 class="text-xl text-blue-600">法向加速度(向心加速度) a<sub>n</sub></h4>
                    <ul class="list-disc ml-5 my-2">
                        <li>方向指向圆心</li>
                        <li>大小为 a<sub>n</sub> = v²/r</li>
                        <li>表示速度方向的变化</li>
                    </ul>
                </div>
                <div class="card">
                    <h4 class="text-xl text-blue-600">切向加速度 a<sub>t</sub></h4>
                    <ul class="list-disc ml-5 my-2">
                        <li>方向与速度方向相同或相反</li>
                        <li>大小为 a<sub>t</sub> = dv/dt</li>
                        <li>表示速度大小的变化</li>
                    </ul>
                </div>
            </div>
            
            <p>总加速度为这两个分量的矢量和：</p>
            <div class="formula">
                <div id="formula-total-acceleration"></div>
            </div>
            
            <p>其中 e<sub>n</sub> 和 e<sub>t</sub> 分别是法向和切向单位矢量。</p>
            
            <div class="canvas-container">
                <div id="non-uniform-circular-motion-canvas"></div>
                <div class="interactive-controls">
                    <div class="control-group">
                        <label for="tangential-acceleration-slider">切向加速度 (a<sub>t</sub>):</label>
                        <div class="slider-container">
                            <input type="range" id="tangential-acceleration-slider" min="-50" max="50" value="20" class="w-full">
                            <span id="tangential-acceleration-value">20 单位/秒<sup>2</sup></span>
                        </div>
                    </div>
                    <button id="reset-simulation" class="btn">重置模拟</button>
                </div>
                <div class="mt-4">
                    <p><strong>当前速率 (v): <span id="current-velocity">0 单位/秒</span></strong></p>
                    <p><strong>法向加速度 (a<sub>n</sub>): <span id="normal-acceleration">0 单位/秒<sup>2</sup></span></strong></p>
                    <p><strong>总加速度 (a): <span id="total-acceleration">20 单位/秒<sup>2</sup></span></strong></p>
                    <p><strong>加速度与法向夹角 (φ): <span id="acceleration-angle">90°</span></strong></p>
                </div>
            </div>
            
            <p>加速度的大小和方向可通过以下公式计算：</p>
            <div class="formula">
                <div id="formula-acceleration-magnitude"></div>
                <div id="formula-acceleration-direction"></div>
            </div>
        </section>
        
        <section>
            <h2>自然坐标系</h2>
            <p>在分析圆周运动和一般曲线运动时，常采用以运动点为原点，以切向和法向为坐标轴的自然坐标系。这种坐标系对分析加速度分量特别方便。</p>
            
            <div class="canvas-container">
                <div id="natural-coordinate-canvas"></div>
            </div>
            
            <p>在自然坐标系中：</p>
            <ul class="list-disc ml-8 my-4">
                <li>切向单位矢量 e<sub>t</sub> 与速度方向相同</li>
                <li>法向单位矢量 e<sub>n</sub> 垂直于速度方向，指向曲率中心</li>
                <li>对于圆周运动，曲率中心就是圆心</li>
            </ul>
            
            <div class="tip-box">
                <p class="font-bold">扩展知识：</p>
                <p>自然坐标系也称为Frenet坐标系，不仅适用于圆周运动，也适用于任何曲线运动。在一般曲线运动中，法向加速度与曲率半径ρ有关：a<sub>n</sub> = v²/ρ。</p>
            </div>
        </section>
        
        <section>
            <h2>应用示例</h2>
            
            <div class="grid-container">
                <div class="card">
                    <h3 class="text-center">行星运动</h3>
                    <p>行星绕太阳的运动可近似为圆周运动，其向心加速度由万有引力提供。根据牛顿第二定律和万有引力定律：</p>
                    <div class="formula">
                        <div id="formula-planetary-motion"></div>
                    </div>
                    <p>这解释了开普勒第三定律的物理本质，行星运动周期的平方与轨道半径的立方成正比。</p>
                </div>
                
                <div class="card">
                    <h3 class="text-center">向心力</h3>
                    <p>由F = ma得知，要维持匀速圆周运动，必须有向心力：</p>
                    <div class="formula">
                        <div id="formula-centripetal-force"></div>
                    </div>
                    <p>例如，当汽车转弯时，轮胎与地面的摩擦力提供向心力；当卫星绕地球运行时，地球引力提供向心力。</p>
                </div>
            </div>
            
            <div class="card mt-6">
                <h3 class="text-center">日常生活中的应用</h3>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mt-4">
                    <div class="bg-blue-50 p-4 rounded-lg">
                        <h4 class="text-lg font-bold text-blue-700">离心机</h4>
                        <p>利用圆周运动产生的"离心力"（实际是惯性效应）分离不同密度的物质。例如医学实验室用于分离血液成分。</p>
                    </div>
                    <div class="bg-blue-50 p-4 rounded-lg">
                        <h4 class="text-lg font-bold text-blue-700">过山车</h4>
                        <p>在圆弧轨道上运动时，乘客体验到的"压力"增加是由向心加速度引起的。过山车设计师精确计算这些力以创造安全且刺激的体验。</p>
                    </div>
                    <div class="bg-blue-50 p-4 rounded-lg">
                        <h4 class="text-lg font-bold text-blue-700">人造重力</h4>
                        <p>在太空站中，可以通过旋转产生人造重力，使宇航员体验类似地球的重力环境，减少失重带来的健康问题。</p>
                    </div>
                </div>
            </div>
        </section>
        
        <section>
            <h2>小结</h2>
            <p>圆周运动是物理学中的基础概念，了解它对理解更复杂的物理现象至关重要。让我们回顾一下本教程的核心知识点：</p>
            
            <table>
                <thead>
                    <tr>
                        <th>概念</th>
                        <th>公式</th>
                        <th>说明</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>角速度</td>
                        <td>ω = dθ/dt</td>
                        <td>描述角位置变化的速率</td>
                    </tr>
                    <tr>
                        <td>线速率与角速度关系</td>
                        <td>v = rω</td>
                        <td>速率等于半径与角速度的乘积</td>
                    </tr>
                    <tr>
                        <td>向心加速度</td>
                        <td>a<sub>n</sub> = v²/r = rω²</td>
                        <td>指向圆心，改变速度方向</td>
                    </tr>
                    <tr>
                        <td>切向加速度</td>
                        <td>a<sub>t</sub> = dv/dt</td>
                        <td>沿切线方向，改变速度大小</td>
                    </tr>
                    <tr>
                        <td>周期</td>
                        <td>T = 2π/ω</td>
                        <td>完成一周所需的时间</td>
                    </tr>
                    <tr>
                        <td>频率</td>
                        <td>f = 1/T = ω/2π</td>
                        <td>单位时间内完成的圈数</td>
                    </tr>
                </tbody>
            </table>
            
            <div class="info-box mt-6">
                <p class="font-bold">重要原则：</p>
                <ol class="list-decimal ml-5">
                    <li>匀速圆周运动中加速度不为零，而是有向心加速度。</li>
                    <li>圆周运动的加速度方向不一定指向圆心，除非是匀速圆周运动。</li>
                    <li>维持圆周运动需要力，向心力是保持物体做圆周运动的必要条件。</li>
                    <li>所谓"离心力"不是真正的力，而是惯性效应，在非惯性参考系中引入的一种虚拟力。</li>
                </ol>
            </div>
            
            <p class="mt-6">圆周运动是理解更复杂曲线运动的基础，掌握好圆周运动的概念和特性，将为你学习后续的物理力学内容奠定坚实基础。</p>
        </section>
        
        <div class="mt-8 p-6 bg-blue-50 rounded-lg">
            <h2 class="text-center border-none">思考与练习</h2>
            <ol class="list-decimal ml-8">
                <li>地球围绕太阳运动，假设轨道为圆形，半径为1.5×10¹¹米，试计算地球的向心加速度。</li>
                <li>一辆汽车以20m/s的速度过一半径为100m的弯道，计算汽车的向心加速度。如果路面与轮胎之间的最大静摩擦系数为0.8，这个弯道能否安全通过？</li>
                <li>一个小物块放在水平转盘上，转盘以角速度ω旋转。如果小物块与转盘间的静摩擦系数为μ，试推导出小物块不会从转盘上甩出的最大半径。</li>
                <li>考虑地球自转带来的影响，同一物体在赤道和南北极的重力加速度是否相同？为什么？</li>
            </ol>
        </div>
    </div>
    
    <script>
        // KaTeX渲染数学公式
        document.addEventListener('DOMContentLoaded', function() {
            // 极坐标转换公式
            katex.render("x = r \\cos \\theta", document.getElementById('formula-conversion1'));
            katex.render("y = r \\sin \\theta", document.getElementById('formula-conversion2'));
            
            // 角速度公式
            katex.render("\\omega = \\frac{d\\theta}{dt}", document.getElementById('formula-angular-velocity'));
            
            // 速率和角速度关系公式
            katex.render("v = r\\omega", document.getElementById('formula-v-omega'));
            
            // 向心加速度公式
            katex.render("a_n = \\frac{v^2}{r} = r\\omega^2", document.getElementById('formula-centripetal-acceleration'));
            
            // 总加速度公式
            katex.render("\\vec{a} = a_n\\vec{e_n} + a_t\\vec{e_t} = \\frac{v^2}{r}\\vec{e_n} + \\frac{dv}{dt}\\vec{e_t}", document.getElementById('formula-total-acceleration'));
            
            // 加速度大小和方向公式
            katex.render("a = \\sqrt{a_n^2 + a_t^2}", document.getElementById('formula-acceleration-magnitude'));
            katex.render("\\tan\\phi = \\frac{a_t}{a_n}", document.getElementById('formula-acceleration-direction'));
            
            // 行星运动公式
            katex.render("\\frac{mv^2}{r} = G\\frac{Mm}{r^2} \\Rightarrow v^2 = \\frac{GM}{r}", document.getElementById('formula-planetary-motion'));
            
            // 向心力公式
            katex.render("F = ma_n = m\\frac{v^2}{r} = mr\\omega^2", document.getElementById('formula-centripetal-force'));
        });

        // 平面极坐标系可视化
        let polarSketch = function(p) {
            let radius = 100;
            let angle = 45;
            
            p.setup = function() {
                let canvas = p.createCanvas(400, 400);
                canvas.parent('polar-coordinates-canvas');
            };
            
            p.draw = function() {
                p.background(255);
                
                // 绘制坐标轴
                p.stroke(200);
                p.line(0, p.height/2, p.width, p.height/2);
                p.line(p.width/2, 0, p.width/2, p.height);
                
                // 绘制圆形网格
                p.noFill();
                p.stroke(220);
                for (let r = 50; r <= 200; r += 50) {
                    p.circle(p.width/2, p.height/2, r*2);
                }
                
                // 绘制角度网格
                p.push();
                p.translate(p.width/2, p.height/2);
                for (let a = 0; a < 360; a += 30) {
                    let rad = p.radians(a);
                    p.stroke(220);
                    p.line(0, 0, 200 * p.cos(rad), 200 * p.sin(rad));
                    p.noStroke();
                    p.fill(150);
                    p.text(a + "°", 210 * p.cos(rad), 210 * p.sin(rad));
                }
                p.pop();
                
                // 绘制点
                p.push();
                p.translate(p.width/2, p.height/2);
                let rad = p.radians(angle);
                let x = radius * p.cos(rad);
                let y = radius * p.sin(rad);
                
                // 绘制r线
                p.stroke(255, 0, 0, 150);
                p.line(0, 0, x, y);
                
                // 绘制角度弧
                p.noFill();
                p.stroke(0, 150, 255, 200);
                p.arc(0, 0, 40, 40, 0, rad);
                
                // 绘制角度标签
                p.fill(0, 150, 255);
                p.noStroke();
                p.text("θ = " + angle + "°", 25 * p.cos(rad/2), 25 * p.sin(rad/2));
                
                // 绘制点
                p.fill(255, 0, 0);
                p.noStroke();
                p.circle(x, y, 10);
                
                // 绘制坐标信息
                p.fill(0);
                p.text("r = " + radius, x + 10, y);
                p.text("(x, y) = (" + p.nf(x, 0, 1) + ", " + p.nf(y, 0, 1) + ")", x + 10, y + 15);
                
                // 绘制到坐标轴的投影
                p.stroke(100, 100);
                p.line(x, y, x, 0);
                p.line(x, y, 0, y);
                
                p.pop();
            };
            
            // 外部函数更新参数
            p.updateParams = function(r, a) {
                radius = r;
                angle = a;
            };
        };
        
        // 角速度可视化
        let angularVelocitySketch = function(p) {
            let omega = 2; // rad/s
            let radius = 80;
            let angle = 0;
            let lastTime = 0;
            let trailPoints = [];
            let maxTrailPoints = 100;
            let showTrail = true;
            
            p.setup = function() {
                let canvas = p.createCanvas(400, 400);
                canvas.parent('angular-velocity-canvas');
                lastTime = p.millis() / 1000;
            };
            
            p.draw = function() {
                p.background(255);
                
                // 计算时间增量和新角度
                let currentTime = p.millis() / 1000;
                let dt = currentTime - lastTime;
                lastTime = currentTime;
                
                angle += omega * dt;
                if (angle > p.TWO_PI) {
                    angle -= p.TWO_PI;
                }
                
                // 绘制坐标轴
                p.stroke(200);
                p.line(0, p.height/2, p.width, p.height/2);
                p.line(p.width/2, 0, p.width/2, p.height);
                
                // 绘制圆
                p.push();
                p.translate(p.width/2, p.height/2);
                p.noFill();
                p.stroke(220);
                p.circle(0, 0, radius*2);
                
                // 计算点的位置
                let x = radius * p.cos(angle);
                let y = radius * p.sin(angle);
                
                // 更新轨迹点
                trailPoints.push({x: x, y: y});
                if (trailPoints.length > maxTrailPoints) {
                    trailPoints.shift();
                }
                
                // 绘制轨迹
                if (showTrail) {
                    p.noFill();
                    p.stroke(255, 0, 0, 100);
                    p.beginShape();
                    for (let point of trailPoints) {
                        p.vertex(point.x, point.y);
                    }
                    p.endShape();
                }
                
                // 绘制径向线
                p.stroke(255, 0, 0, 150);
                p.line(0, 0, x, y);
                
                // 绘制速度矢量
                p.stroke(0, 200, 0);
                p.fill(0, 200, 0);
                let vx = -y; // 速度向量x分量，垂直于半径
                let vy = x;  // 速度向量y分量，垂直于半径
                let v = radius * omega; // 速度大小
                let vScale = v / 30; // 缩放速度矢量以便显示
                
                // 绘制速度矢量
                p.line(x, y, x + vx * vScale, y + vy * vScale);
                p.push();
                p.translate(x + vx * vScale, y + vy * vScale);
                p.rotate(angle + p.HALF_PI);
                p.triangle(0, 0, -5, -10, 5, -10);
                p.pop();
                
                // 绘制角度标签
                p.noStroke();
                p.fill(0, 150, 255);
                p.text("θ = " + p.nf(p.degrees(angle), 0, 1) + "°", 10, -radius - 20);
                
                // 绘制点
                p.fill(255, 0, 0);
                p.noStroke();
                p.circle(x, y, 10);
                
                // 添加标签
                p.fill(0);
                p.text("ω = " + omega + " rad/s", 10, -radius - 40);
                p.text("r = " + radius, 10, -radius - 60);
                p.text("v = r·ω = " + p.nf(v, 0, 1), 10, -radius - 80);
                
                p.pop();
                
                // 更新显示值
                document.getElementById('linear-velocity').innerText = p.nf(radius * omega, 0, 0) + " 单位/秒";
                document.getElementById('period').innerText = p.nf(p.TWO_PI / omega, 0, 2) + " 秒";
            };
            
            // 外部函数更新参数
            p.updateParams = function(w, r) {
                omega = w;
                radius = r;
                trailPoints = []; // 清除轨迹
            };
        };
        
        // 匀速圆周运动可视化
        let uniformCircularMotionSketch = function(p) {
            let velocity = 100; // 速率
            let radius = 80;    // 半径
            let angle = 0;      // 当前角度
            let lastTime = 0;   // 上一帧时间
            let showAcceleration = false; // 是否显示加速度
            
            p.setup = function() {
                let canvas = p.createCanvas(400, 400);
                canvas.parent('uniform-circular-motion-canvas');
                lastTime = p.millis() / 1000;
            };
            
            p.draw = function() {
                p.background(255);
                
                // 计算时间增量和新角度
                let currentTime = p.millis() / 1000;
                let dt = currentTime - lastTime;
                lastTime = currentTime;
                
                let omega = velocity / radius; // 角速度
                angle += omega * dt;
                if (angle > p.TWO_PI) {
                    angle -= p.TWO_PI;
                }
                
                // 绘制坐标轴
                p.stroke(200);
                p.line(0, p.height/2, p.width, p.height/2);
                p.line(p.width/2, 0, p.width/2, p.height);
                
                // 绘制圆
                p.push();
                p.translate(p.width/2, p.height/2);
                p.noFill();
                p.stroke(220);
                p.circle(0, 0, radius*2);
                
                // 计算点的位置
                let x = radius * p.cos(angle);
                let y = radius * p.sin(angle);
                
                // 绘制径向线
                p.stroke(255, 0, 0, 150);
                p.line(0, 0, x, y);
                
                // 计算向心加速度
                let a_n = velocity * velocity / radius;
                let aScale = a_n / 200; // 缩放加速度矢量以便显示
                
                // 绘制速度矢量
                p.stroke(0, 200, 0);
                p.fill(0, 200, 0);
                let vx = -y; // 速度向量x分量，垂直于半径
                let vy = x;  // 速度向量y分量，垂直于半径
                let vScale = velocity / 100; // 缩放速度矢量以便显示
                
                // 绘制速度矢量
                p.line(x, y, x + vx * vScale, y + vy * vScale);
                p.push();
                p.translate(x + vx * vScale, y + vy * vScale);
                p.rotate(angle + p.HALF_PI);
                p.triangle(0, 0, -5, -10, 5, -10);
                p.pop();
                
                // 绘制向心加速度矢量
                if (showAcceleration) {
                    p.stroke(255, 0, 255);
                    p.fill(255, 0, 255);
                    let ax = -x; // 加速度向量x分量，指向圆心
                    let ay = -y; // 加速度向量y分量，指向圆心
                    
                    // 归一化并缩放
                    let aMag = p.sqrt(ax*ax + ay*ay);
                    ax = ax / aMag * a_n * aScale;
                    ay = ay / aMag * a_n * aScale;
                    
                    p.line(x, y, x + ax, y + ay);
                    p.push();
                    p.translate(x + ax, y + ay);
                    p.rotate(angle + p.PI);
                    p.triangle(0, 0, -5, -10, 5, -10);
                    p.pop();
                    
                    // 添加向心加速度标签
                    p.noStroke();
                    p.fill(255, 0, 255);
                    p.text("a_n = " + p.nf(a_n, 0, 0) + " 单位/秒²", x + ax, y + ay - 10);
                }
                
                // 绘制点
                p.fill(255, 0, 0);
                p.noStroke();
                p.circle(x, y, 10);
                
                // 添加标签
                p.fill(0);
                p.text("v = " + velocity + " 单位/秒", 10, -radius - 20);
                p.text("r = " + radius, 10, -radius - 40);
                p.text("ω = v/r = " + p.nf(omega, 0, 2) + " rad/s", 10, -radius - 60);
                
                p.pop();
                
                // 更新显示值
                document.getElementById('centripetal-acceleration').innerText = p.nf(velocity * velocity / radius, 0, 0) + " 单位/秒²";
                document.getElementById('angular-velocity-calc').innerText = p.nf(velocity / radius, 0, 2) + " rad/s";
            };
            
            // 外部函数更新参数
            p.updateParams = function(v, r) {
                velocity = v;
                radius = r;
            };
            
            p.toggleAcceleration = function() {
                showAcceleration = !showAcceleration;
            };
        };
        
        // 变速圆周运动可视化
        let nonUniformCircularMotionSketch = function(p) {
            let radius = 80;               // 半径
            let angle = 0;                 // 当前角度
            let velocity = 0;              // 初始速度
            let tangentialAcceleration = 20; // 切向加速度
            let lastTime = 0;              // 上一帧时间
            
            p.setup = function() {
                let canvas = p.createCanvas(400, 400);
                canvas.parent('non-uniform-circular-motion-canvas');
                lastTime = p.millis() / 1000;
            };
            
            p.draw = function() {
                p.background(255);
                
                // 计算时间增量
                let currentTime = p.millis() / 1000;
                let dt = currentTime - lastTime;
                lastTime = currentTime;
                
                // 更新速度和角度
                velocity += tangentialAcceleration * dt;
                velocity = p.constrain(velocity, -300, 300); // 限制速度范围
                
                let omega = velocity / radius; // 角速度
                angle += omega * dt;
                
                // 绘制坐标轴
                p.stroke(200);
                p.line(0, p.height/2, p.width, p.height/2);
                p.line(p.width/2, 0, p.width/2, p.height);
                
                // 绘制圆
                p.push();
                p.translate(p.width/2, p.height/2);
                p.noFill();
                p.stroke(220);
                p.circle(0, 0, radius*2);
                
                // 计算点的位置
                let x = radius * p.cos(angle);
                let y = radius * p.sin(angle);
                
                // 绘制径向线
                p.stroke(255, 0, 0, 150);
                p.line(0, 0, x, y);
                
                // 计算法向加速度（向心加速度）
                let a_n = velocity * velocity / radius;
                
                // 计算总加速度
                let a_total = p.sqrt(a_n*a_n + tangentialAcceleration*tangentialAcceleration);
                let accelerationAngle = p.atan2(tangentialAcceleration, a_n);
                
                // 缩放因子
                let vScale = p.abs(velocity) / 150;
                let aScale = a_total / 200;
                
                // 绘制速度矢量
                p.stroke(0, 200, 0);
                p.fill(0, 200, 0);
                let vx = -y; // 速度向量x分量，垂直于半径
                let vy = x;  // 速度向量y分量，垂直于半径
                
                // 如果速度是负的，反转方向
                if (velocity < 0) {
                    vx = -vx;
                    vy = -vy;
                }
                
                // 绘制速度矢量
                p.line(x, y, x + vx * vScale, y + vy * vScale);
                p.push();
                p.translate(x + vx * vScale, y + vy * vScale);
                p.rotate(angle + (velocity >= 0 ? p.HALF_PI : -p.HALF_PI));
                p.triangle(0, 0, -5, -10, 5, -10);
                p.pop();
                
                // 绘制法向加速度矢量（向心加速度）
                p.stroke(255, 0, 255);
                p.fill(255, 0, 255);
                let anx = -x; // 法向加速度x分量，指向圆心
                let any = -y; // 法向加速度y分量，指向圆心
                
                // 归一化
                let anMag = p.sqrt(anx*anx + any*any);
                anx = anx / anMag;
                any = any / anMag;
                
                // 绘制法向加速度矢量
                let anScaled = a_n / 300;
                p.line(x, y, x + anx * anScaled, y + any * anScaled);
                
                // 绘制切向加速度矢量
                p.stroke(255, 150, 0);
                p.fill(255, 150, 0);
                let atx = vx / p.sqrt(vx*vx + vy*vy); // 切向加速度x分量，与速度方向相同
                let aty = vy / p.sqrt(vx*vx + vy*vy); // 切向加速度y分量，与速度方向相同
                
                // 绘制切向加速度矢量
                let atScaled = p.abs(tangentialAcceleration) / 100;
                if (tangentialAcceleration < 0) {
                    atx = -atx;
                    aty = -aty;
                }
                
                p.line(x, y, x + atx * atScaled, y + aty * atScaled);
                
                // 绘制总加速度矢量
                p.stroke(100, 100, 255);
                p.fill(100, 100, 255);
                
                // 计算总加速度方向（将法向和切向分量合成）
                let ax = anx * a_n + atx * tangentialAcceleration;
                let ay = any * a_n + aty * tangentialAcceleration;
                
                // 归一化
                let aMag = p.sqrt(ax*ax + ay*ay);
                ax = ax / aMag * a_total * aScale;
                ay = ay / aMag * a_total * aScale;
                
                p.line(x, y, x + ax, y + ay);
                p.push();
                p.translate(x + ax, y + ay);
                p.rotate(p.atan2(ay, ax));
                p.triangle(0, 0, -5, -10, 5, -10);
                p.pop();
                
                // 绘制点
                p.fill(255, 0, 0);
                p.noStroke();
                p.circle(x, y, 10);
                
                // 添加标签
                p.fill(0);
                p.text("v = " + p.nf(velocity, 0, 0) + " 单位/秒", 10, -radius - 20);
                p.text("a_t = " + tangentialAcceleration + " 单位/秒²", 10, -radius - 40);
                p.text("a_n = " + p.nf(a_n, 0, 0) + " 单位/秒²", 10, -radius - 60);
                p.text("a_total = " + p.nf(a_total, 0, 0) + " 单位/秒²", 10, -radius - 80);
                
                p.pop();
                
                // 更新显示值
                document.getElementById('current-velocity').innerText = p.nf(velocity, 0, 0) + " 单位/秒";
                document.getElementById('normal-acceleration').innerText = p.nf(a_n, 0, 0) + " 单位/秒²";
                document.getElementById('total-acceleration').innerText = p.nf(a_total, 0, 0) + " 单位/秒²";
                document.getElementById('acceleration-angle').innerText = p.nf(p.degrees(accelerationAngle), 0, 1) + "°";
            };
            
            // 外部函数更新参数
            p.updateParams = function(at) {
                tangentialAcceleration = at;
            };
            
            p.resetSimulation = function() {
                velocity = 0;
                angle = 0;
            };
        };
        
        // 自然坐标系可视化
        let naturalCoordinateSketch = function(p) {
            let angle = 0;
            let radius = 80;
            
            p.setup = function() {
                let canvas = p.createCanvas(400, 400);
                canvas.parent('natural-coordinate-canvas');
            };
            
            p.draw = function() {
                p.background(255);
                
                // 自动旋转
                angle += 0.01;
                if (angle > p.TWO_PI) {
                    angle -= p.TWO_PI;
                }
                
                // 绘制坐标轴
                p.stroke(200);
                p.line(0, p.height/2, p.width, p.height/2);
                p.line(p.width/2, 0, p.width/2, p.height);
                
                // 绘制圆
                p.push();
                p.translate(p.width/2, p.height/2);
                p.noFill();
                p.stroke(220);
                p.circle(0, 0, radius*2);
                
                // 计算点的位置
                let x = radius * p.cos(angle);
                let y = radius * p.sin(angle);
                
                // 绘制切向单位矢量
                p.stroke(0, 200, 0);
                p.fill(0, 200, 0);
                let tx = -y / radius; // 切向单位矢量x分量
                let ty = x / radius;  // 切向单位矢量y分量
                
                p.line(x, y, x + tx * 30, y + ty * 30);
                p.push();
                p.translate(x + tx * 30, y + ty * 30);
                p.rotate(angle + p.HALF_PI);
                p.triangle(0, 0, -5, -10, 5, -10);
                p.pop();
                
                p.noStroke();
                p.text("e_t", x + tx * 35, y + ty * 35);
                
                // 绘制法向单位矢量
                p.stroke(255, 0, 255);
                p.fill(255, 0, 255);
                let nx = -x / radius; // 法向单位矢量x分量，指向圆心
                let ny = -y / radius; // 法向单位矢量y分量，指向圆心
                
                p.line(x, y, x + nx * 30, y + ny * 30);
                p.push();
                p.translate(x + nx * 30, y + ny * 30);
                p.rotate(angle + p.PI);
                p.triangle(0, 0, -5, -10, 5, -10);
                p.pop();
                
                p.noStroke();
                p.text("e_n", x + nx * 35, y + ny * 35);
                
                // 绘制点
                p.fill(255, 0, 0);
                p.noStroke();
                p.circle(x, y, 10);
                
                // 绘制坐标系说明
                p.fill(0);
                p.text("自然坐标系 (e_t, e_n)", -radius, -radius - 20);
                p.text("e_t: 切向单位矢量，与速度方向相同", -radius, -radius - 40);
                p.text("e_n: 法向单位矢量，指向曲率中心", -radius, -radius - 60);
                
                p.pop();
            };
        };
        
        // 初始化P5.js实例
        let polarCoordinatesInstance = new p5(polarSketch);
        let angularVelocityInstance = new p5(angularVelocitySketch);
        let uniformCircularMotionInstance = new p5(uniformCircularMotionSketch);
        let nonUniformCircularMotionInstance = new p5(nonUniformCircularMotionSketch);
        let naturalCoordinateInstance = new p5(naturalCoordinateSketch);
        
        // 平面极坐标系控制器
        document.getElementById('radius-slider').addEventListener('input', function() {
            let radius = parseInt(this.value);
            document.getElementById('radius-value').textContent = radius;
            polarCoordinatesInstance.updateParams(radius, parseInt(document.getElementById('angle-slider').value));
        });
        
        document.getElementById('angle-slider').addEventListener('input', function() {
            let angle = parseInt(this.value);
            document.getElementById('angle-value').textContent = angle + '°';
            polarCoordinatesInstance.updateParams(parseInt(document.getElementById('radius-slider').value), angle);
        });
        
        // 角速度控制器
        document.getElementById('omega-slider').addEventListener('input', function() {
            let omega = parseFloat(this.value);
            document.getElementById('omega-value').textContent = omega + ' rad/s';
            angularVelocityInstance.updateParams(omega, parseInt(document.getElementById('radius-slider2').value));
        });
        
        document.getElementById('radius-slider2').addEventListener('input', function() {
            let radius = parseInt(this.value);
            document.getElementById('radius-value2').textContent = radius;
            angularVelocityInstance.updateParams(parseFloat(document.getElementById('omega-slider').value), radius);
        });
        
        // 匀速圆周运动控制器
        document.getElementById('velocity-slider').addEventListener('input', function() {
            let velocity = parseInt(this.value);
            document.getElementById('velocity-value').textContent = velocity + ' 单位/秒';
            uniformCircularMotionInstance.updateParams(velocity, parseInt(document.getElementById('radius-slider3').value));
        });
        
        document.getElementById('radius-slider3').addEventListener('input', function() {
            let radius = parseInt(this.value);
            document.getElementById('radius-value3').textContent = radius;
            uniformCircularMotionInstance.updateParams(parseInt(document.getElementById('velocity-slider').value), radius);
        });
        
        document.getElementById('toggle-acceleration').addEventListener('click', function() {
            uniformCircularMotionInstance.toggleAcceleration();
        });
        
        // 变速圆周运动控制器
        document.getElementById('tangential-acceleration-slider').addEventListener('input', function() {
            let at = parseInt(this.value);
            document.getElementById('tangential-acceleration-value').textContent = at + ' 单位/秒²';
            nonUniformCircularMotionInstance.updateParams(at);
        });
        
        document.getElementById('reset-simulation').addEventListener('click', function() {
            nonUniformCircularMotionInstance.resetSimulation();
        });
    </script>
</body>
</html>
